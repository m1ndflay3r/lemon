#!/usr/bin/env bash

# Promps for input, returns true if response is a variant of yes and returns false if it isn't. Can accept a string for input prompt dialogue
function isyes {
  if [ ! -z "$1" ]; then
    read -p "$1  " ANSWER
  else
    read ANSWER
  fi
  if [ -z "$ANSWER" ]; then
    ANSWER="y"
  fi
  if [ $ANSWER == y ] || [ $ANSWER == Y ] || [ $ANSWER == yes ] || [ $ANSWER == Yes ] || [ $ANSWER == YES ]; then
    yes=0 && return 0
  else
    yes=0 && return 0
  fi
}

# Takes input in the form of an array, and checks each array item against user input.
# Returns true if a match is found and false if the response does not exist in the input array.
# User input is stored in $RESPONSE.
#
# Syntax: isvalidresponse "${INPUTARRAY[@]}"
#
function isvalidresponse {
  RESPONSE="NULL"
  read RESPONSE
  if [ -z "$RESPONSE" ]; then
    RESPONSE="NULL"
  fi
  for i in "${@}"; do
    if echo "$i" | grep $RESPONSE &> /dev/null; then
      return 0
    else
      false
    fi
  done
}

# Executes input from $1 once, then repeats as long as isvalidresponse returns false.
# syntax: untilvalidresponse 'echo foo; echo bar' "${INPUTARRAY[@]}"
#
function untilvalidresponse {
  eval "$1"
  until isvalidresponse "${@:2}"; do
    echo "Invalid response!"
    eval "$1"
  done
}

# Tests network connectivity, returning false when the user does not answer yes to retry or after 10 seconds if $1 is --noretry.
# Returns true if wget is succesful in the beginning or during the 10 second count.
#
function nettest {
  echo "Testing internet connection"
  until ping 8.8.8.8 -c 1 &> /dev/null; do
    COUNT="0"
    until [ $COUNT == 10 ]; do
      echo "."
      sleep 1
      COUNT=$((COUNT + 1))
      if ping 8.8.8.8 -c 1 &> /dev/null; then
        return 0
      fi
    done
    echo "Network unreachable after 10 seconds!"
    sleep 0.5
    if [ "$1" == --noretry ]; then
      return 1
    else
      if ! isyes "Retry? (Y/n)"; then
        return 1
      fi
    fi
  done
}

# Executes input operations once, then repeats them until nettest passes.
# Syntax: untilnetpass 'echo foo; echo bar'
#
function untilnetpass {
  eval "$@"
  until nettest; do
    eval "$@"
  done
}

# AUR package installation logic
# Ideally this should be run in a subshell to prevent bizzare behavior if makepkg fails.
#
function aurinst {
  mkdir $HOME/.aurtool
  cd $HOME/.aurtool
  git clone http://aur.archlinux.org/$@.git
  cd $@
  PKGB=./PKGBUILD
  if [ ! -f $PKGB ]; then
    echo "ERROR: Package $@ does not exist!"
    echo "Failed AUR package: $@ (invalid package name)" >> /home/aur/aur.log
    return 1
  else
    if isyes "Would you like to edit the PKGBUILD? (Y/n)"; then
      if which nano &> /dev/null; then
        nano ./PKGBUILD
      else
        vim ./PKGBUILD
      fi
    fi
    if ! (makepkg -cs); then
      echo "ERROR: Package $@ failed to build!"
      echo "Failed AUR package: $@ (build failure)" >> /home/aur/aur.log
      return 1
    else
      sudo pacman -U --noconfirm *.pkg.tar*
    fi
    rm -rf $HOME/.aurtool
    return 0
  fi
}
